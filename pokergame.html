<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Poker Game</title>
  <style>
    :root{
      --bg:#0b3d2e; --text:#eaf7f2; --muted:#bfe6d9; --acc:#ffcf5a;
      --line:rgba(255,255,255,.14); --danger:#ff4d4d; --ok:#6bffb1;
    }
    html,body{height:100%}
    body{margin:0;font-family:system-ui;background:radial-gradient(1200px 800px at 50% 15%, #14624a, var(--bg));color:var(--text);overflow:hidden}

    header{
      padding:10px 12px;display:flex;gap:10px;justify-content:space-between;align-items:center;flex-wrap:wrap;
      background:rgba(0,0,0,.18);border-bottom:1px solid var(--line);
    }
    .badge{font-size:12px;padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.06);color:var(--muted)}
    .big{font-weight:1000;color:var(--acc)}
    button,input,select{border:1px solid var(--line);background:rgba(0,0,0,.18);color:var(--text);padding:10px;border-radius:12px;outline:none}
    button{cursor:pointer;font-weight:900}
    button:disabled{opacity:.5;cursor:not-allowed}
    button.readyOn{background:rgba(31,122,74,.45);border-color:rgba(107,255,177,.55);color:#eafff4}

    .app{height:calc(100vh - 62px);display:flex;flex-direction:column;padding:10px;gap:10px;min-height:0}
    .topbar{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}

    .tabs{display:flex;gap:8px}
    .tab{min-width:120px;display:flex;align-items:center;justify-content:center;gap:8px}
    .tab.active{border-color:rgba(255,207,90,.6);box-shadow:0 0 0 6px rgba(255,207,90,.08)}
    .hidden{display:none}

    .panel{border:1px solid var(--line);border-radius:16px;background:rgba(0,0,0,.16);padding:12px;min-height:0}

    /* GAME */
    .gameView{flex:1;min-height:0;display:flex;flex-direction:column}
    .tableWrap{
      flex:1;min-height:0;display:grid;grid-template-columns:1fr 260px;gap:10px;
      border:1px solid rgba(255,255,255,.12);border-radius:18px;background:rgba(255,255,255,.06);padding:10px;overflow:hidden
    }
    .table{
      position:relative;width:100%;height:100%;border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,.12);
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.06), transparent 40%),
        radial-gradient(circle at 70% 70%, rgba(0,0,0,.25), transparent 45%),
        repeating-linear-gradient(45deg, rgba(255,255,255,.03), rgba(255,255,255,.03) 6px, transparent 6px, transparent 12px),
        radial-gradient(ellipse at center, #0f5a3f, #083b2a);
      box-shadow: inset 0 0 60px rgba(0,0,0,.55), 0 20px 60px rgba(0,0,0,.45);
    }
    .boardCenter{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:min(740px,94%);padding:10px 8px;border-radius:16px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);text-align:center
    }
    .boardRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;align-items:center;min-height:72px}
    .myHandRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:10px}
    .hint{font-size:12px;color:var(--muted);line-height:1.35;margin-top:8px}

    .card{width:46px;height:64px;background:#f7f7f7;color:#1b1b1b;border-radius:10px;display:flex;flex-direction:column;justify-content:space-between;padding:6px;border:1px solid rgba(0,0,0,.12)}
    .card.red{color:#c21d1d}

    .seat{position:absolute;width:160px;padding:8px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);transform:translate(-50%,-50%);font-size:11px}
    .seat .topline{display:flex;justify-content:space-between;gap:8px;align-items:center}
    .seat .name{font-weight:900;max-width:110px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .seat.folded{opacity:.55}
    .seat.me{border-color:rgba(107,255,177,.35)}
    .seat .handMini{display:flex;gap:6px;justify-content:center;margin-top:8px;flex-wrap:wrap}
    .seat .handMini .card{transform:scale(.72);transform-origin:center}

    @keyframes blinkRed{0%,100%{box-shadow:0 0 0 0 rgba(255,77,77,.0)}50%{box-shadow:0 0 0 14px rgba(255,77,77,.22)}}
    .seat.toActBlink{
      outline:5px solid rgba(255,77,77,1);animation:blinkRed .85s infinite;
      box-shadow:0 0 0 6px rgba(255,77,77,.25),0 0 25px rgba(255,77,77,.65),inset 0 0 18px rgba(255,77,77,.25);
    }
    .turnDot{display:inline-block;width:10px;height:10px;border-radius:50%;background:var(--danger);box-shadow:0 0 10px rgba(255,77,77,.6);animation:blinkRed .85s infinite;margin-right:8px;}
    .winnerBanner{margin-top:10px;padding:10px 12px;border-radius:16px;border:2px solid rgba(255,207,90,.55);background:rgba(0,0,0,.42);font-weight:1000;font-size:22px;color:#ffe6a6}
    .winnerBanner.hidden{display:none}

    .actionPanel{display:flex;flex-direction:column;gap:8px;padding:12px;border-radius:16px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);box-shadow:0 10px 30px rgba(0,0,0,.45);min-width:0}
    .actionPanel button,.actionPanel input{width:100%}
    .turnBox{padding:8px 10px;border-radius:14px;border:1px solid rgba(255,77,77,.35);background:rgba(255,77,77,.08);display:flex;align-items:center;font-weight:900;color:#ffd5d5}
    .turnBox.hidden{display:none}

    /* CHAT (k√ºl√∂n f√ºl, k√ºl√∂n view, bels≈ë scroll) */
    #viewChat{flex:1;display:flex;min-height:0}
    .chatGrid{flex:1;min-height:0;height:100%;display:grid;grid-template-columns:360px 1fr;gap:10px}
    .scrollBox{min-height:0;overflow:auto;border:1px solid var(--line);border-radius:14px;padding:10px;background:rgba(255,255,255,.06)}
    .chatbox{flex:1;min-height:0;overflow:auto;border:1px solid var(--line);border-radius:14px;padding:10px;background:rgba(0,0,0,.18);white-space:pre-wrap}
    .chatSend{display:flex;gap:8px;margin-top:10px}
    .chatSend input{flex:1}
    .chatline{margin:0 0 8px 0;color:var(--muted)}
    .chatline b{color:var(--acc)}
    .mention{color:var(--acc);font-weight:900}
    #chatNotif{background:#ff4d4d;color:white;font-size:10px;padding:2px 6px;border-radius:999px;border:1px solid rgba(0,0,0,.18)}

    /* HOST (k√ºl√∂n f√ºl, k√ºl√∂n view) */
    #viewHost{flex:1;min-height:0}
    .hostRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px}
    .pill{font-size:12px;padding:3px 8px;border-radius:999px;border:1px solid var(--line);color:var(--muted)}
    .pill.ready{border-color:rgba(107,255,177,.4);color:var(--ok)}
    .pill.notready{border-color:rgba(255,107,107,.4);color:var(--danger)}

    @media (max-width: 980px){
      body{overflow:auto}
      .app{height:auto}
      .chatGrid{grid-template-columns:1fr}
      .tableWrap{grid-template-columns:1fr;height:520px}
    }
  </style>
</head>
<body>
<header>
  <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
    <span class="badge">Szoba: <b id="room"></b></span>
    <span class="badge">Te: <b id="me"></b></span>
    <span class="badge">Kapcsolat: <b id="status">‚Äî</b></span>
    <span class="badge">Host: <b id="hostLbl">‚Äî</b></span>
    <span class="badge">Sz√©k: <b id="seatLbl">‚Äî</b></span>
  </div>
  <div class="big" id="phaseLbl">V√°rakoz√°s‚Ä¶</div>
</header>

<div class="app">
  <div class="topbar">
    <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
      <button id="readyBtn">K√âSZ / READY</button>
      <span class="badge">Utca: <b id="streetLbl">‚Äî</b></span>
      <span class="badge">Pot: <b id="potLbl">0</b></span>
      <span class="badge">Aktu√°lis t√©t: <b id="currentBetLbl">0</b></span>
      <span class="badge">K√∂r: <b id="handNoLbl">0</b></span>
    </div>

    <!-- ‚úÖ 3 K√úL√ñN TAB -->
    <div class="tabs">
      <button class="tab active" id="tabGame">J√°t√©k</button>
      <button class="tab" id="tabChat">Chat <span id="chatNotif" class="pill hidden">‚óè</span></button>
      <button class="tab hidden" id="tabHost">Host</button>
    </div>
  </div>

  <!-- GAME VIEW -->
  <section class="panel gameView" id="viewGame">
    <div class="tableWrap">
      <div class="table" id="table">
        <div class="boardCenter">
          <div class="badge" style="display:inline-block;margin-bottom:8px">K√∂z√∂s lapok</div>
          <div class="boardRow" id="boardRow"></div>

          <div class="badge" style="display:inline-block;margin:10px 0 6px 0">Saj√°t lapjaid</div>
          <div class="myHandRow" id="myHandRow"></div>

          <div class="hint" id="turnHint">‚Äî</div>
          <div id="winnerBanner" class="winnerBanner hidden"></div>
        </div>
        <div id="seatLayer"></div>
      </div>

      <div class="actionPanel">
        <div id="yourTurnBox" class="turnBox hidden"><span class="turnDot"></span>TE VAGY SORON!</div>
        <button id="btnCall">PASS</button>
        <button id="btnFold">DOB√ÅS</button>
        <input id="raiseAmt" type="number" value="40" min="0" step="10" />
        <button id="btnRaise">T√âT / EMEL√âS</button>
      </div>
    </div>
  </section>

  <!-- CHAT VIEW (k√ºl√∂n) -->
  <section class="panel hidden" id="viewChat">
    <div class="chatGrid">
      <div class="scrollBox" id="playersBox">
        <div class="badge">J√°t√©kosok</div>
        <div class="hint">N√©v ‚Ä¢ üí∞ ‚Ä¢ Ready</div>
        <div id="players" style="margin-top:10px"></div>
      </div>
      <div style="min-height:0;height:100%;display:flex;flex-direction:column;gap:10px">
        <div class="badge">Chat</div>
        <div class="chatbox" id="chatBox"></div>
        <div class="chatSend">
          <input id="chatMsg" placeholder="√çrj‚Ä¶ (@Bruno)" maxlength="300" />
          <button id="chatSend">K√ºld√©s</button>
        </div>
        <div class="hint">Taggel√©s: <b>@N√©v</b> (csak kiemel√©s)</div>
      </div>
    </div>
  </section>

  <!-- HOST VIEW (k√ºl√∂n) -->
  <section class="panel hidden" id="viewHost">
    <div class="badge">Host be√°ll√≠t√°sok</div>
    <div class="hint">Ez a men√º csak a hostnak l√°tszik.</div>

    <div class="hostRow">
      <label class="badge">Robotok:
        <select id="botCount">
          <option>0</option><option>1</option><option>2</option><option selected>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
        </select>
      </label>

      <label class="badge">Kezd≈ë stack:
        <select id="stackSel">
          <option value="500">500</option>
          <option value="1000" selected>1000</option>
          <option value="2000">2000</option>
          <option value="5000">5000</option>
        </select>
      </label>

      <label class="badge">Vakok:
        <select id="blindsSel">
          <option value="5,10">5/10</option>
          <option value="10,20" selected>10/20</option>
          <option value="25,50">25/50</option>
          <option value="50,100">50/100</option>
        </select>
      </label>
    </div>

    <div class="hostRow">
      <button id="btnPushCfg">Be√°ll√≠t√°sok ment√©se</button>
      <button id="btnStart">‚ñ∂ J√°t√©k ind√≠t√°sa</button>
      <button id="btnNewHand">üîÑ √öj k√∂r</button>
      <button id="btnNewGame">üîÅ √öj j√°t√©k</button>
    </div>

    <div class="hostRow">
      <label class="badge">Zseton ad√°s (k√∂r v√©g√©n):
        <select id="topupPlayer"></select>
      </label>
      <input id="topupAmt" type="number" value="500" min="1" step="50" style="width:140px" />
      <button id="btnTopup">‚ûï Add</button>
    </div>
  </section>
</div>

<script>
  const qs = new URLSearchParams(location.search);
  const room = (qs.get("room")||"").trim();
  const name = (qs.get("name")||"").trim();
  const wsUrl = (qs.get("ws")||"").trim();
  const pw = sessionStorage.getItem("poker_room_pw") || "";

  if(!room || !name || !wsUrl || !pw){
    alert("Hi√°nyz√≥ adatok. Menj vissza a lobbyba!");
    location.href = "pokerlobby.html";
  }

  const ui = {
    room: document.getElementById("room"),
    me: document.getElementById("me"),
    status: document.getElementById("status"),
    hostLbl: document.getElementById("hostLbl"),
    seatLbl: document.getElementById("seatLbl"),
    phaseLbl: document.getElementById("phaseLbl"),

    streetLbl: document.getElementById("streetLbl"),
    potLbl: document.getElementById("potLbl"),
    currentBetLbl: document.getElementById("currentBetLbl"),
    handNoLbl: document.getElementById("handNoLbl"),

    tabGame: document.getElementById("tabGame"),
    tabChat: document.getElementById("tabChat"),
    tabHost: document.getElementById("tabHost"),
    chatNotif: document.getElementById("chatNotif"),

    viewGame: document.getElementById("viewGame"),
    viewChat: document.getElementById("viewChat"),
    viewHost: document.getElementById("viewHost"),

    readyBtn: document.getElementById("readyBtn"),

    boardRow: document.getElementById("boardRow"),
    myHandRow: document.getElementById("myHandRow"),
    seatLayer: document.getElementById("seatLayer"),
    tableEl: document.getElementById("table"),
    turnHint: document.getElementById("turnHint"),
    winnerBanner: document.getElementById("winnerBanner"),

    yourTurnBox: document.getElementById("yourTurnBox"),
    btnCall: document.getElementById("btnCall"),
    btnFold: document.getElementById("btnFold"),
    btnRaise: document.getElementById("btnRaise"),
    raiseAmt: document.getElementById("raiseAmt"),

    players: document.getElementById("players"),
    chatBox: document.getElementById("chatBox"),
    chatMsg: document.getElementById("chatMsg"),
    chatSend: document.getElementById("chatSend"),

    botCount: document.getElementById("botCount"),
    stackSel: document.getElementById("stackSel"),
    blindsSel: document.getElementById("blindsSel"),
    btnPushCfg: document.getElementById("btnPushCfg"),
    btnStart: document.getElementById("btnStart"),
    btnNewHand: document.getElementById("btnNewHand"),
    btnNewGame: document.getElementById("btnNewGame"),
    topupPlayer: document.getElementById("topupPlayer"),
    topupAmt: document.getElementById("topupAmt"),
    btnTopup: document.getElementById("btnTopup"),
  };

  ui.room.textContent = room;
  ui.me.textContent = name;

  let ws, clientId=null, hostId=null, isHost=false, mySeat=null;
  let lobby = { humans:[], ready:{}, cfg:{bots:3, stack:1000, blinds:"10,20"}, started:false };
  let state=null;      // synced state from host
  let hostState=null;  // host‚Äôs local authoritative state

  function send(obj){ if(ws && ws.readyState===1) ws.send(JSON.stringify(obj)); }

  function switchTab(which){
    ui.tabGame.classList.toggle("active", which==="game");
    ui.tabChat.classList.toggle("active", which==="chat");
    ui.tabHost.classList.toggle("active", which==="host");

    ui.viewGame.classList.toggle("hidden", which!=="game");
    ui.viewChat.classList.toggle("hidden", which!=="chat");
    ui.viewHost.classList.toggle("hidden", which!=="host");

    if(which==="chat") ui.chatNotif.classList.add("hidden");
  }
  ui.tabGame.onclick = ()=>switchTab("game");
  ui.tabChat.onclick = ()=>switchTab("chat");
  ui.tabHost.onclick = ()=>switchTab("host");
  switchTab("game");

  function escapeHtml(s){
    return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
  }
  function highlightMentionsSafe(text){
    const safe = escapeHtml(text);
    return safe.replace(/@([^\s]+)/g, (m,p1)=>`<span class="mention">@${p1}</span>`);
  }
  function appendChat(n,t){
    const p=document.createElement("p");
    p.className="chatline";
    p.innerHTML = `<b>${escapeHtml(n)}:</b> ${highlightMentionsSafe(t)}`;
    ui.chatBox.appendChild(p);
    ui.chatBox.scrollTop = ui.chatBox.scrollHeight;
    if(ui.viewChat.classList.contains("hidden")) ui.chatNotif.classList.remove("hidden");
  }

  ui.chatSend.onclick = ()=>{
    const text = ui.chatMsg.value.trim().slice(0,300);
    if(!text) return;
    ui.chatMsg.value="";
    send({ type:"intent", intent:"chat", text });
  };
  ui.chatMsg.addEventListener("keydown",(e)=>{ if(e.key==="Enter") ui.chatSend.click(); });

  ui.readyBtn.onclick = ()=>{
    const cur = !!lobby.ready[clientId];
    send({ type:"intent", intent: cur ? "unready" : "ready" });
  };

  function everyoneReady(){
    return lobby.humans.length>0 && lobby.humans.every(h => lobby.ready[h.clientId] === true);
  }

  function syncHostTabVisibility(){
    ui.tabHost.classList.toggle("hidden", !isHost);
    if(!isHost && ui.tabHost.classList.contains("active")) switchTab("game");
  }

  // ====== GAME LOGIC (host authority, minimal, stable) ======
  const SUITS=["‚ô†","‚ô•","‚ô¶","‚ô£"];
  const RANKS=["2","3","4","5","6","7","8","9","10","J","Q","K","A"];
  const RANK_VALUE=Object.fromEntries(RANKS.map((r,i)=>[r,i+2]));
  const isRedSuit = (s)=> s==="‚ô•" || s==="‚ô¶";
  const makeDeck=()=>{ const d=[]; for(const s of SUITS) for(const r of RANKS) d.push({r,s}); return d; };
  const shuffle=(a)=>{ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; };

  function renderCard(c){
    const d=document.createElement("div");
    d.className="card"+(isRedSuit(c.s)?" red":"");
    d.innerHTML = `<div style="font-weight:900;font-size:16px;line-height:1">${c.r}</div><div style="align-self:flex-end;font-size:16px;line-height:1">${c.s}</div>`;
    return d;
  }
  function faceDown(){
    const d=document.createElement("div");
    d.className="card";
    d.style.background="rgba(0,0,0,.18)";
    d.style.color="rgba(255,255,255,.65)";
    d.innerHTML="<div style='font-weight:900'>?</div><div style='align-self:flex-end'>üÇ†</div>";
    return d;
  }

  function findStraightHigh(uniqueDesc){
    const set=new Set(uniqueDesc);
    const wheel=[14,5,4,3,2];
    if(wheel.every(v=>set.has(v))) return 5;
    for(const high of uniqueDesc){
      let ok=true;
      for(let d=1;d<=4;d++){ if(!set.has(high-d)){ ok=false; break; } }
      if(ok) return high;
    }
    return null;
  }
  function evaluate7(cards){
    const vals=cards.map(c=>RANK_VALUE[c.r]).sort((a,b)=>b-a);
    const byRank=new Map();
    for(const c of cards){ const v=RANK_VALUE[c.r]; byRank.set(v,(byRank.get(v)||0)+1); }
    const groups=[...byRank.entries()].map(([v,c])=>({v,c})).sort((a,b)=>(b.c-a.c)||(b.v-a.v));
    const bySuit=new Map();
    for(const c of cards){ if(!bySuit.has(c.s)) bySuit.set(c.s,[]); bySuit.get(c.s).push(RANK_VALUE[c.r]); }
    for(const [s,arr] of bySuit) arr.sort((a,b)=>b-a);
    const flushSuit=[...bySuit.entries()].find(([s,arr])=>arr.length>=5)?.[0] ?? null;

    const unique=[...new Set(vals)];
    const straight=findStraightHigh(unique);

    let sf=null;
    if(flushSuit){
      const fv=[...new Set(bySuit.get(flushSuit))].sort((a,b)=>b-a);
      sf=findStraightHigh(fv);
    }
    if(sf) return {cat:8,t:[sf],name:"sz√≠nsor"};
    if(groups[0]?.c===4){ const q=groups[0].v; const k=unique.find(v=>v!==q); return {cat:7,t:[q,k],name:"p√≥ker"}; }
    if(groups[0]?.c===3 && groups[1]?.c>=2) return {cat:6,t:[groups[0].v,groups[1].v],name:"full house"};
    if(flushSuit) return {cat:5,t:bySuit.get(flushSuit).slice(0,5),name:"sz√≠n"};
    if(straight) return {cat:4,t:[straight],name:"sor"};
    if(groups[0]?.c===3){ const tr=groups[0].v; const k=unique.filter(v=>v!==tr).slice(0,2); return {cat:3,t:[tr,...k],name:"drill"}; }
    if(groups[0]?.c===2 && groups[1]?.c===2){
      const hi=Math.max(groups[0].v,groups[1].v), lo=Math.min(groups[0].v,groups[1].v);
      const k=unique.find(v=>v!==hi && v!==lo);
      return {cat:2,t:[hi,lo,k],name:"k√©t p√°r"};
    }
    if(groups[0]?.c===2){ const pr=groups[0].v; const k=unique.filter(v=>v!==pr).slice(0,3); return {cat:1,t:[pr,...k],name:"p√°r"}; }
    return {cat:0,t:unique.slice(0,5),name:"magas lap"};
  }
  function cmpEval(a,b){
    if(a.cat!==b.cat) return a.cat>b.cat?1:-1;
    for(let i=0;i<Math.max(a.t.length,b.t.length);i++){
      const av=a.t[i]??0, bv=b.t[i]??0;
      if(av!==bv) return av>bv?1:-1;
    }
    return 0;
  }

  function amountToCall(st,p){ return Math.max(0, st.currentBet - p.bet); }
  function countAlive(st){ return st.players.filter(p=>p.inHand && !p.folded).length; }
  function nextEligibleIndex(st, from){
    const n=st.players.length;
    for(let t=1;t<=n;t++){
      const idx=(from+t)%n;
      const p=st.players[idx];
      if(p.inHand && !p.folded) return idx;
    }
    return from;
  }
  function nextActionIndex(st, from){
    const n=st.players.length;
    for(let t=1;t<=n;t++){
      const idx=(from+t)%n;
      const p=st.players[idx];
      if(p.inHand && !p.folded && !p.allIn) return idx;
    }
    return null;
  }
  function bettingClosed(st){
    if(countAlive(st)<=1) return true;
    const elig=st.players.filter(p=>p.inHand && !p.folded && !p.allIn);
    if(elig.length===0) return true;
    const acted=new Set(st.acted||[]);
    for(const p of elig){
      if(p.bet!==st.currentBet) return false;
      if(!acted.has(p.id)) return false;
    }
    return true;
  }
  function hist(st, text){
    st.history = st.history || [];
    st.history.push(text);
    if(st.history.length>250) st.history.shift();
    st.msg=text;
  }
  function postBlind(st, idx, amt, label){
    const p=st.players[idx];
    const pay=Math.min(amt, p.stack);
    p.stack-=pay; p.bet+=pay; p.totalInvested+=pay; st.pot+=pay;
    if(p.stack===0) p.allIn=true;
    hist(st, `${p.name}: ${label} ${pay}`);
  }

  function startHand(st){
    st.handNo++;
    st.showdownInfo=null;
    st.deck = shuffle(makeDeck());
    st.community=[];
    st.pot=0;
    st.street="PREFLOP";
    st.currentBet=0;
    st.acted=[];
    st.handActive=true;

    for(const p of st.players){
      p.hand=[]; p.inHand=p.stack>0; p.folded=!p.inHand; p.allIn=false; p.bet=0; p.totalInvested=0; p._eval=null;
    }

    st.dealer = nextEligibleIndex(st, st.dealer);

    for(let k=0;k<2;k++){
      for(let i=0;i<st.players.length;i++){
        const idx=(st.dealer+1+i)%st.players.length;
        if(st.players[idx].inHand) st.players[idx].hand.push(st.deck.pop());
      }
    }

    st.sbIndex = nextEligibleIndex(st, st.dealer);
    st.bbIndex = nextEligibleIndex(st, st.sbIndex);

    postBlind(st, st.sbIndex, st.cfg.sb, "SB");
    postBlind(st, st.bbIndex, st.cfg.bb, "BB");

    st.currentBet = Math.max(...st.players.map(p=>p.bet));
    st.toAct = nextEligibleIndex(st, st.bbIndex);
    st.acted=[];
    hist(st, `Kezd√©s: preflop. Bet=${st.currentBet}`);
  }

  function actFold(st, idx){
    st.players[idx].folded=true;
    st.acted.push(idx);
    hist(st, `${st.players[idx].name}: dob√°s`);
    if(countAlive(st)<=1){
      const w=st.players.find(p=>p.inHand && !p.folded);
      if(w) w.stack += st.pot;
      st.handActive=false;
      st.street="SHOWDOWN";
      st.showdownInfo = w ? { winners:[w.name], handName:"mindenki dobott" } : null;
      return;
    }
    st.toAct = bettingClosed(st) ? null : nextActionIndex(st, idx);
  }
  function actCallCheck(st, idx){
    const p=st.players[idx];
    const call=amountToCall(st,p);
    const pay=Math.min(call, p.stack);
    p.stack-=pay; p.bet+=pay; p.totalInvested+=pay; st.pot+=pay;
    if(p.stack===0 && call>0) p.allIn=true;
    hist(st, call===0 ? `${p.name}: passz` : `${p.name}: megad ${pay}${pay<call?" (all-in)":""}`);
    st.acted.push(idx);
    st.toAct = bettingClosed(st) ? null : nextActionIndex(st, idx);
  }
  function actRaiseTo(st, idx, raiseToRaw){
    const p=st.players[idx];
    let raiseTo = Number(raiseToRaw||0);
    if(raiseTo <= st.currentBet){ actCallCheck(st, idx); return; }

    const need=Math.max(0, raiseTo - p.bet);
    const pay=Math.min(need, p.stack);
    p.stack-=pay; p.bet+=pay; p.totalInvested+=pay; st.pot+=pay;
    if(p.stack===0) p.allIn=true;

    st.currentBet = p.bet;
    st.acted = [idx];
    hist(st, `${p.name}: emel ${st.currentBet}-ig${p.allIn?" (all-in)":""}`);
    st.toAct = bettingClosed(st) ? null : nextActionIndex(st, idx);
  }

  function advanceStreet(st){
    if(!st.handActive) return;
    if(!bettingClosed(st)) return;

    if(countAlive(st)<=1){
      const w=st.players.find(p=>p.inHand && !p.folded);
      if(w) w.stack += st.pot;
      st.handActive=false;
      st.street="SHOWDOWN";
      st.showdownInfo = w ? { winners:[w.name], handName:"mindenki dobott" } : null;
      return;
    }

    for(const p of st.players) p.bet=0;
    st.currentBet=0;
    st.acted=[];
    st.toAct = nextEligibleIndex(st, st.dealer);

    if(st.street==="PREFLOP"){ st.deck.pop(); st.community.push(st.deck.pop(),st.deck.pop(),st.deck.pop()); st.street="FLOP"; }
    else if(st.street==="FLOP"){ st.deck.pop(); st.community.push(st.deck.pop()); st.street="TURN"; }
    else if(st.street==="TURN"){ st.deck.pop(); st.community.push(st.deck.pop()); st.street="RIVER"; }
    else if(st.street==="RIVER"){ st.street="SHOWDOWN"; doShowdown(st); }
  }

  function doShowdown(st){
    const alive = st.players.filter(p=>p.inHand && !p.folded);
    for(const p of alive) p._eval = evaluate7(p.hand.concat(st.community));

    let best = alive[0]._eval;
    for(const p of alive) if(cmpEval(p._eval,best)>0) best=p._eval;
    const winnersOverall = alive.filter(p=>cmpEval(p._eval,best)===0).map(p=>p.name);
    st.showdownInfo = { winners: winnersOverall, handName: best.name };

    // side-pot kifizet√©s
    const investedAll = st.players
      .map(p=>({id:p.id,inv:Number(p.totalInvested||0)}))
      .filter(x=>x.inv>0).sort((a,b)=>a.inv-b.inv);

    const levels = [...new Set(investedAll.map(x=>x.inv))].sort((a,b)=>a-b);
    const won = new Map(st.players.map(p=>[p.id,0]));
    let prev=0;

    for(const L of levels){
      const inTier = st.players.filter(p=>Number(p.totalInvested||0) >= L);
      const tierAmount = (L-prev)*inTier.length; prev=L;
      if(tierAmount<=0) continue;

      const eligible = inTier.filter(p=>p.inHand && !p.folded);
      if(!eligible.length) continue;

      let bestTier=eligible[0]._eval;
      for(const p of eligible) if(cmpEval(p._eval,bestTier)>0) bestTier=p._eval;
      const winners = eligible.filter(p=>cmpEval(p._eval,bestTier)===0);

      const share = Math.floor(tierAmount / winners.length);
      let rem = tierAmount - share*winners.length;
      const ordered = winners.slice().sort((a,b)=>a.id-b.id);

      for(const w of ordered){ w.stack += share; won.set(w.id,(won.get(w.id)||0)+share); }
      for(let i=0;i<ordered.length && rem>0;i++){ ordered[i].stack+=1; won.set(ordered[i].id,(won.get(ordered[i].id)||0)+1); rem--; }
    }

    st.handActive=false;
  }

  // bot 3s delay
  let botTimer=null;
  function scheduleBot(st){
    if(!isHost || !st || !st.handActive) return;
    if(st.toAct==null) return;
    const p=st.players[st.toAct];
    if(!p?.isBot) return;
    if(botTimer) return;

    botTimer=setTimeout(()=>{
      botTimer=null;
      if(!hostState || !hostState.handActive) return;
      const idx=hostState.toAct;
      const bp=hostState.players[idx];
      if(!bp?.isBot) return;

      const call=amountToCall(hostState,bp);
      const r=Math.random();
      if(call>0 && r<0.25) actFold(hostState, idx);
      else if(r<0.12 && bp.stack > call + hostState.cfg.bb) actRaiseTo(hostState, idx, hostState.currentBet + hostState.cfg.bb);
      else actCallCheck(hostState, idx);

      let guard=0;
      while(hostState.handActive && hostState.street!=="SHOWDOWN" && bettingClosed(hostState) && guard++<50){
        advanceStreet(hostState);
      }

      send({ type:"state", state: hostState });
      scheduleBot(hostState);
    }, 3000);
  }

  function buildInitialState(){
    const humans = lobby.humans.slice();
    const cfg = lobby.cfg || { bots:3, stack:1000, blinds:"10,20" };
    const bots = Math.max(0, Math.min(10, Number(cfg.bots||0)));
    const stack = Number(cfg.stack||1000);
    const [sb,bb] = String(cfg.blinds||"10,20").split(",").map(n=>Number(n));

    const players = [
      ...humans.map((h,idx)=>({ id:idx, name:h.name, isBot:false, stack, hand:[], inHand:true, folded:false, allIn:false, bet:0, totalInvested:0 })),
      ...Array.from({length:bots}).map((_,i)=>({ id:humans.length+i, name:`Robot #${i+1}`, isBot:true, stack, hand:[], inHand:true, folded:false, allIn:false, bet:0, totalInvested:0 })),
    ];

    return { cfg:{sb,bb,stack,bots}, players, community:[], pot:0, street:"PREFLOP", currentBet:0, acted:[], toAct:null,
      handNo:0, dealer:0, sbIndex:null, bbIndex:null, deck:[], handActive:false, showdownInfo:null };
  }

  // UI actions
  ui.btnFold.onclick = ()=> send({ type:"intent", intent:"action", action:"fold", seat: mySeat });
  ui.btnCall.onclick = ()=> send({ type:"intent", intent:"action", action:"call", seat: mySeat });
  ui.btnRaise.onclick = ()=> send({ type:"intent", intent:"action", action:"raise", seat: mySeat, amount: Number(ui.raiseAmt.value||0) });

  // Host actions
  function pushHostCfg(){
    if(!isHost) return;
    const cfg = { bots:Number(ui.botCount.value||0), stack:Number(ui.stackSel.value||1000), blinds: ui.blindsSel.value };
    lobby.cfg = { ...lobby.cfg, ...cfg };
    send({ type:"intent", intent:"hostConfig", cfg });
  }
  ui.btnPushCfg.onclick = pushHostCfg;

  ui.btnStart.onclick = ()=>{
    if(!isHost) return;
    if(!everyoneReady()) return alert("Nem minden ember K√âSZ.");
    lobby.started=true;
    hostState = buildInitialState();
    startHand(hostState);
    send({ type:"start", state: hostState });
    send({ type:"state", state: hostState });
    scheduleBot(hostState);
  };
  ui.btnNewHand.onclick = ()=>{
    if(!isHost) return;
    if(!hostState || hostState.handActive) return alert("A k√∂r m√©g tart.");
    startHand(hostState);
    send({ type:"state", state: hostState });
    scheduleBot(hostState);
  };
  ui.btnNewGame.onclick = ()=>{
    if(!isHost) return;
    if(!everyoneReady()) return alert("√öj j√°t√©khoz minden ember legyen K√âSZ.");
    lobby.started=true;
    hostState = buildInitialState();
    startHand(hostState);
    send({ type:"start", state: hostState });
    send({ type:"state", state: hostState });
    scheduleBot(hostState);
  };

  ui.btnTopup.onclick = ()=>{
    if(!isHost || !hostState) return;
    if(hostState.handActive) return alert("Zsetont csak k√∂r v√©g√©n adj!");
    const seat = Number(ui.topupPlayer.value);
    const amt = Math.max(1, Number(ui.topupAmt.value||0));
    const p = hostState.players?.[seat];
    if(!p || p.isBot) return alert("Csak ember j√°t√©kosnak adhatsz!");
    p.stack += amt;
    send({ type:"state", state: hostState });
  };

  // seat positions: everyone sees themselves bottom
  function clamp(n,a,b){ return Math.max(a,Math.min(b,n)); }
  function getSeatPos(i,n){
    const me = (mySeat==null?0:mySeat);
    const rel = (i - me + n) % n;
    const angleStart = Math.PI/2;
    const step = (2*Math.PI)/Math.max(2,n);
    const a = angleStart + rel*step;

    const rect = ui.tableEl.getBoundingClientRect();
    const rx = rect.width*0.41, ry=rect.height*0.37;
    const cx=50, cy=50;
    let x = cx + (Math.cos(a)*(rx/rect.width)*100);
    let y = cy + (Math.sin(a)*(ry/rect.height)*100);
    x=clamp(x,10,90); y=clamp(y,12,88);
    return {x,y};
  }

  function renderTable(st){
    ui.boardRow.innerHTML="";
    for(const c of (st.community||[])) ui.boardRow.appendChild(renderCard(c));

    ui.myHandRow.innerHTML="";
    if(mySeat!=null && st.players?.[mySeat]?.hand?.length===2){
      ui.myHandRow.appendChild(renderCard(st.players[mySeat].hand[0]));
      ui.myHandRow.appendChild(renderCard(st.players[mySeat].hand[1]));
    } else { ui.myHandRow.appendChild(faceDown()); ui.myHandRow.appendChild(faceDown()); }

    const showAllHands = (st.street==="SHOWDOWN") || (!st.handActive);

    ui.seatLayer.innerHTML="";
    const n = st.players.length;

    for(let i=0;i<n;i++){
      const p=st.players[i];
      const pos=getSeatPos(i,n);
      const el=document.createElement("div");
      el.className="seat";
      el.style.left=pos.x+"%";
      el.style.top=pos.y+"%";
      if(st.handActive && st.toAct===i) el.classList.add("toActBlink");
      if(p.folded) el.classList.add("folded");
      if(mySeat===i) el.classList.add("me");

      el.innerHTML = `
        <div class="topline">
          <div class="name" title="${escapeHtml(p.name)}">${escapeHtml(p.name)}${p.isBot?" ü§ñ":""}</div>
          <div>üí∞ ${p.stack}</div>
        </div>
        <div style="margin-top:6px;font-weight:900;color:var(--acc)">T√©t: ${p.bet} ${p.allIn?"‚Ä¢ ALL-IN":""} ${p.folded?"‚Ä¢ DOBOTT":""}</div>
      `;

      if(showAllHands && !p.folded && p.hand?.length===2){
        const row=document.createElement("div");
        row.className="handMini";
        row.appendChild(renderCard(p.hand[0]));
        row.appendChild(renderCard(p.hand[1]));
        el.appendChild(row);
        if(p._eval){
          const d=document.createElement("div");
          d.className="hint";
          d.textContent = "Komb√≥: " + p._eval.name;
          el.appendChild(d);
        }
      }

      ui.seatLayer.appendChild(el);
    }
  }

  function renderPlayersList(){
    ui.players.innerHTML="";
    for(const h of lobby.humans){
      const row=document.createElement("div");
      row.style.display="flex";
      row.style.justifyContent="space-between";
      row.style.gap="10px";
      row.style.padding="6px 0";
      row.style.borderBottom="1px dashed rgba(255,255,255,.12)";

      const left=document.createElement("div");
      left.textContent = h.name;

      const money=document.createElement("div");
      money.textContent = "üí∞ " + (state?.players?.[h.seat]?.stack ?? "‚Äî");
      money.style.color="var(--muted)";
      money.style.fontSize="12px";

      const right=document.createElement("span");
      const ok = lobby.ready[h.clientId]===true;
      right.className = "pill " + (ok?"ready":"notready");
      right.textContent = ok ? "K√âSZ" : "NEM K√âSZ";

      row.appendChild(left); row.appendChild(money); row.appendChild(right);
      ui.players.appendChild(row);
    }

    // host topup dropdown
    ui.topupPlayer.innerHTML="";
    for(let i=0;i<lobby.humans.length;i++){
      const opt=document.createElement("option");
      opt.value=String(i);
      opt.textContent = lobby.humans[i].name;
      ui.topupPlayer.appendChild(opt);
    }
  }

  function render(){
    ui.hostLbl.textContent = hostId ? "van" : "‚Äî";
    ui.seatLbl.textContent = (mySeat==null?"‚Äî":String(mySeat));
    ui.phaseLbl.textContent = lobby.started ? "J√°t√©k fut" : "V√°rakoz√°s‚Ä¶";

    syncHostTabVisibility();

    const isReady = lobby.ready[clientId]===true;
    ui.readyBtn.textContent = isReady ? "K√âSZ ‚úî" : "K√âSZ / READY";
    ui.readyBtn.classList.toggle("readyOn", isReady);

    renderPlayersList();

    if(!lobby.started || !state){
      ui.streetLbl.textContent="‚Äî";
      ui.potLbl.textContent="0";
      ui.currentBetLbl.textContent="0";
      ui.handNoLbl.textContent="0";
      ui.turnHint.textContent="V√°rakoz√°s a host ind√≠t√°s√°ra‚Ä¶";
      ui.winnerBanner.classList.add("hidden");
      ui.btnCall.disabled=ui.btnFold.disabled=ui.btnRaise.disabled=true;
      ui.yourTurnBox.classList.add("hidden");
      ui.boardRow.innerHTML=""; ui.myHandRow.innerHTML=""; ui.seatLayer.innerHTML="";
      return;
    }

    ui.streetLbl.textContent = ({PREFLOP:"Preflop",FLOP:"Flop",TURN:"Turn",RIVER:"River",SHOWDOWN:"Showdown"}[state.street]||state.street);
    ui.potLbl.textContent = String(state.pot||0);
    ui.currentBetLbl.textContent = String(state.currentBet||0);
    ui.handNoLbl.textContent = String(state.handNo||0);

    renderTable(state);

    const canAct = state.handActive && state.toAct===mySeat;
    ui.btnCall.disabled = ui.btnFold.disabled = ui.btnRaise.disabled = !canAct;
    ui.yourTurnBox.classList.toggle("hidden", !canAct);

    // PASS -> MEGAD:X
    if(canAct){
      const meP = state.players[mySeat];
      const need = amountToCall(state, meP);
      ui.btnCall.textContent = need>0 ? `MEGAD: ${need}` : "PASS";
    } else ui.btnCall.textContent="PASS";

    if((state.street==="SHOWDOWN" || !state.handActive) && state.showdownInfo?.winners?.length){
      ui.winnerBanner.textContent = `üèÜ Nyertes: ${state.showdownInfo.winners.join(", ")} ‚Äî ${state.showdownInfo.handName}`;
      ui.winnerBanner.classList.remove("hidden");
    } else ui.winnerBanner.classList.add("hidden");

    if(!state.handActive){
      ui.turnHint.textContent = "K√∂r v√©ge. Host: √öj k√∂r / √öj j√°t√©k.";
    } else {
      const actor = state.players[state.toAct];
      ui.turnHint.textContent = (state.toAct===mySeat) ? "Te j√∂ssz." : (actor.name + " k√∂vetkezik‚Ä¶");
    }
  }

  function connect(){
    ui.status.textContent = "csatlakoz√°s‚Ä¶";
    ws = new WebSocket(wsUrl);

    ws.addEventListener("open", ()=>{
      ui.status.textContent="online";
      send({ type:"join", room, name, pw });
    });

    ws.addEventListener("close", ()=> ui.status.textContent="offline");
    ws.addEventListener("error", ()=> ui.status.textContent="hiba");

    ws.addEventListener("message",(ev)=>{
      let msg; try{ msg=JSON.parse(ev.data); }catch{ return; }

      if(msg.type==="welcome"){
        clientId = msg.clientId;
        hostId = msg.hostId;
        isHost = !!msg.isHost;       // ‚úÖ FIX: nem id-√∂sszehasonl√≠t√°s, hanem server flag
        mySeat = Number(msg.seat);
        send({ type:"getLobby" });
        render();
        return;
      }
      if(msg.type==="hostChanged"){ hostId=msg.hostId; isHost = (clientId && hostId && clientId===hostId); render(); return; }
      if(msg.type==="lobby"){ lobby=msg.lobby; hostId=msg.hostId; isHost = (clientId && hostId && clientId===hostId); render(); return; }

      if(msg.type==="start"){
        lobby.started=true;
        state=msg.state;
        if(isHost) hostState = JSON.parse(JSON.stringify(state));
        render();
        return;
      }
      if(msg.type==="state"){
        state=msg.state;
        if(isHost) hostState = JSON.parse(JSON.stringify(state));
        render();
        return;
      }
      if(msg.type==="chat"){ appendChat(msg.name,msg.text); return; }

      // host receives player actions and applies authority logic
      if(msg.type==="intent" && isHost && msg.intent==="action"){
        if(!hostState || !hostState.handActive) return;
        if(hostState.toAct !== msg.seat) return;

        if(msg.action==="fold") actFold(hostState, msg.seat);
        if(msg.action==="call") actCallCheck(hostState, msg.seat);
        if(msg.action==="raise") actRaiseTo(hostState, msg.seat, Number(msg.amount||0));

        let guard=0;
        while(hostState.handActive && hostState.street!=="SHOWDOWN" && bettingClosed(hostState) && guard++<50){
          advanceStreet(hostState);
        }
        send({ type:"state", state: hostState });
        scheduleBot(hostState);
        return;
      }

      if(msg.type==="error"){ alert(msg.message || "Hiba"); }
    });

    window.addEventListener("resize", ()=> { if(state) render(); });
  }

  connect();
</script>
</body>
</html>
