<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Texas Hold'em ‚Äì Online</title>
  <style>
    :root{--bg:#0b3d2e;--text:#eaf7f2;--muted:#bfe6d9;--acc:#ffcf5a;--line:rgba(255,255,255,.14);--danger:#ff6b6b;--ok:#6bffb1}
    body{margin:0;font-family:system-ui,Arial;background:radial-gradient(1200px 800px at 50% 15%, #14624a, var(--bg));color:var(--text)}
    header{padding:12px 14px;display:flex;gap:10px;justify-content:space-between;align-items:center;background:rgba(0,0,0,.18);border-bottom:1px solid var(--line);flex-wrap:wrap}
    .badge{font-size:12px;padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.06);color:var(--muted)}
    .big{font-size:18px;font-weight:900;color:var(--acc)}
    .wrap{display:grid;grid-template-columns: 1fr 360px;gap:12px;padding:12px}
    @media (max-width: 980px){.wrap{grid-template-columns:1fr}}
    .panel{border:1px solid var(--line);border-radius:16px;background:rgba(0,0,0,.16);padding:12px}
    select,button,input{border:1px solid var(--line);background:rgba(0,0,0,.18);color:var(--text);padding:10px;border-radius:12px;outline:none}
    button{cursor:pointer;font-weight:900}
    button:disabled{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .tabs{display:flex;gap:8px;margin-top:10px}
    .tab{flex:1}
    .tab.active{border-color:rgba(255,207,90,.6);box-shadow:0 0 0 6px rgba(255,207,90,.08)}
    .hidden{display:none}
    .list{margin-top:10px;border:1px solid var(--line);border-radius:14px;padding:10px;background:rgba(255,255,255,.06)}
    .pitem{display:flex;justify-content:space-between;gap:10px;padding:6px 0;border-bottom:1px dashed rgba(255,255,255,.12)}
    .pitem:last-child{border-bottom:none}
    .pill{font-size:12px;padding:3px 8px;border-radius:999px;border:1px solid var(--line);color:var(--muted)}
    .pill.ready{border-color:rgba(107,255,177,.4);color:var(--ok)}
    .pill.notready{border-color:rgba(255,107,107,.4);color:var(--danger)}
    .pill.sb{border-color:rgba(255,207,90,.45);color:var(--acc)}
    .pill.bb{border-color:rgba(255,207,90,.85);color:var(--acc)}
    .pill.d{border-color:rgba(255,207,90,.25);color:var(--acc)}
    .chatbox{height:260px;overflow:auto;border:1px solid var(--line);border-radius:14px;padding:10px;background:rgba(0,0,0,.18);white-space:pre-wrap}
    .chatline{margin:0 0 8px 0;color:var(--muted)}
    .chatline b{color:var(--acc)}
    .chatSend{display:flex;gap:8px;margin-top:10px}
    .chatSend input{flex:1}
    .hint{font-size:12px;color:var(--muted);line-height:1.35;margin-top:10px}
    .card{width:46px;height:64px;background:#f7f7f7;color:#1b1b1b;border-radius:10px;display:flex;flex-direction:column;justify-content:space-between;padding:6px;border:1px solid rgba(0,0,0,.12)}
    .card.red{color:#c21d1d}
    .log{margin-top:10px;height:170px;overflow:auto;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);border-radius:14px;padding:10px;font-size:12px;color:var(--muted);white-space:pre-wrap}

    /* ====== VIZU√ÅLIS ASZTAL ====== */
    .tableWrap{margin-top:12px;border:1px solid rgba(255,255,255,.12);border-radius:18px;background:rgba(255,255,255,.06);padding:12px}
    .table{
      position:relative;
      width:100%;
      max-width:1000px;
      margin:0 auto;
      height:520px;
      border-radius:999px;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.06), rgba(0,0,0,.22));
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
    }
    .table::before{content:"";position:absolute; inset:18px;border-radius:999px;border:1px dashed rgba(255,255,255,.14)}
    .boardCenter{
      position:absolute;left:50%; top:50%;transform:translate(-50%,-50%);
      width:min(620px, 94%);
      padding:10px 8px;border-radius:16px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);text-align:center
    }
    .boardRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;align-items:center;min-height:72px}
    .myHandRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:10px}
    .seat{
      position:absolute;
      width:160px;
      padding:7px 9px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      transform:translate(-50%,-50%);
      font-size:11px;
      line-height:1.2;
    }
    .seat .topline{display:flex;justify-content:space-between;gap:8px;align-items:center}
    .seat .name{
      font-weight:900;color:var(--text);
      max-width:110px;
      overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
    }
    .seat .meta{color:var(--muted);white-space:nowrap}
    .seat .badges{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
    .seat .small{margin-top:6px;color:var(--muted)}
    .seat .handMini{display:flex;gap:6px;justify-content:center;margin-top:8px;flex-wrap:wrap}
    .seat .handMini .card{transform:scale(.8);transform-origin:center}
    .seat.toAct{outline:2px solid rgba(255,207,90,.75);box-shadow:0 0 0 8px rgba(255,207,90,.10)}
    .seat.folded{opacity:.55}
    .seat.me{border-color:rgba(107,255,177,.35)}
    .tableHint{margin-top:8px;color:var(--muted);font-size:12px;text-align:center}
  </style>
</head>
<body>

<header>
  <div class="row" style="gap:10px">
    <span class="badge">Szoba: <b id="room"></b></span>
    <span class="badge">Te: <b id="me"></b></span>
    <span class="badge">Kapcsolat: <b id="status">‚Äî</b></span>
    <span class="badge">Sz√©k: <b id="seat">‚Äî</b></span>
    <span class="badge">Host: <b id="host">‚Äî</b></span>
  </div>
  <div class="big" id="startInfo">V√°rakoz√°s (K√©sz / Ready)‚Ä¶</div>
</header>

<div class="wrap">
  <section class="panel">
    <div class="row">
      <div class="badge">Lobby + J√°t√©k</div>
      <button id="readyBtn">K√âSZ / READY</button>
    </div>

    <div class="tabs">
      <button class="tab active" id="tabGame">J√°t√©k</button>
      <button class="tab" id="tabChat">Chat</button>
    </div>

    <div id="viewGame">
      <div class="hint">
        <b>DEMO:</b> Vakok ‚Üí Preflop ‚Üí Flop ‚Üí Turn ‚Üí River ‚Üí Showdown.
        <b>Emel√©s minimum NINCS</b>: csak legyen nagyobb, mint az aktu√°lis t√©t.
      </div>

      <div id="hostOnly" class="hint" style="margin-top:10px; display:none">
        <b>Host be√°ll√≠t√°sok</b>:
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
          <label class="badge">Robotok:
            <select id="botCount">
              <option>0</option><option>1</option><option>2</option><option selected>3</option><option>4</option>
              <option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
            </select>
          </label>
          <label class="badge">Kezd≈ë zseton:
            <select id="stackSel">
              <option>500</option><option selected>1000</option><option>2000</option><option>5000</option>
            </select>
          </label>
          <label class="badge">Vakok (SB/BB):
            <select id="blindsSel">
              <option value="5,10">5/10</option>
              <option value="10,20" selected>10/20</option>
              <option value="25,50">25/50</option>
              <option value="50,100">50/100</option>
            </select>
          </label>
        </div>

        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="startGameBtn">‚ñ∂ J√ÅT√âK IND√çT√ÅSA</button>
          <button id="newHandBtn">üîÑ √öJ K√ñR</button>
          <button id="newGameBtn">üîÅ √öJ J√ÅT√âK</button>
        </div>

        <!-- ‚úÖ HOST: csak EMBEREK list√°z√°sa -->
        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
          <label class="badge">J√°t√©kos:
            <select id="topupPlayer"></select>
          </label>
          <label class="badge">√ñsszeg:
            <input id="topupAmt" type="number" value="500" min="1" step="50" style="width:120px" />
          </label>
          <button id="topupBtn">‚ûï Zseton ad√°sa</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <span class="badge">Utca: <b id="streetLbl">‚Äî</b></span>
        <span class="badge">Aktu√°lis t√©t: <b id="currentBetLbl">0</b></span>
        <span class="badge">Pot: <b id="potLbl">0</b></span>
        <span class="badge">K√∂r: <b id="handNoLbl">0</b></span>
      </div>

      <div class="tableWrap">
        <div class="table" id="table">
          <div class="boardCenter">
            <div class="badge" style="display:inline-block;margin-bottom:8px">K√∂z√∂s lapok</div>
            <div class="boardRow" id="boardRow"></div>

            <div class="badge" style="display:inline-block;margin:10px 0 6px 0">Saj√°t lapjaid</div>
            <div class="myHandRow" id="myHandRow"></div>
          </div>
          <div id="seatLayer"></div>
        </div>
        <div class="tableHint">Aki soron van, s√°rg√°n kiemelve. Showdown-n√°l a bent maradt j√°t√©kosok lapjai l√°tszanak.</div>
      </div>

      <div class="hint" style="margin-top:10px"><b>Akci√≥k</b> (csak ha te vagy soron):</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
        <button id="actionCall">PASSZ / MEGAD</button>
        <button id="actionFold">DOB√ÅS</button>
        <input id="raiseAmt" type="number" value="40" min="0" step="10" />
        <button id="actionRaise">T√âT / EMEL√âS</button>
      </div>

      <div class="log" id="log"></div>
      <div class="hint" id="turnHint" style="margin-top:10px;font-size:13px">‚Äî</div>
    </div>

    <div id="viewChat" class="hidden">
      <div class="chatbox" id="chatBox"></div>
      <div class="chatSend">
        <input id="chatMsg" placeholder="√çrj valamit‚Ä¶" maxlength="300" />
        <button id="chatSend">K√ºld√©s</button>
      </div>
    </div>
  </section>

  <aside class="panel">
    <div class="badge">Emberek</div>
    <div class="list" id="players"></div>
  </aside>
</div>

<script>
  const qs = new URLSearchParams(location.search);
  const room = (qs.get("room")||"").trim();
  const name = (qs.get("name")||"").trim();
  const wsUrl = (qs.get("ws")||"").trim();
  const pw = sessionStorage.getItem("poker_room_pw") || "";

  if(!room || !name || !wsUrl || !pw){
    alert("Hi√°nyzik a szoba / n√©v / ws / jelsz√≥. Menj vissza a lobbyba!");
    location.href = "pokerlobby.html";
  }

  const ui = {
    room: document.getElementById("room"),
    me: document.getElementById("me"),
    status: document.getElementById("status"),
    seat: document.getElementById("seat"),
    host: document.getElementById("host"),
    startInfo: document.getElementById("startInfo"),

    streetLbl: document.getElementById("streetLbl"),
    currentBetLbl: document.getElementById("currentBetLbl"),
    potLbl: document.getElementById("potLbl"),
    handNoLbl: document.getElementById("handNoLbl"),

    players: document.getElementById("players"),
    log: document.getElementById("log"),
    turnHint: document.getElementById("turnHint"),

    tabGame: document.getElementById("tabGame"),
    tabChat: document.getElementById("tabChat"),
    viewGame: document.getElementById("viewGame"),
    viewChat: document.getElementById("viewChat"),

    readyBtn: document.getElementById("readyBtn"),
    hostOnly: document.getElementById("hostOnly"),
    botCount: document.getElementById("botCount"),
    stackSel: document.getElementById("stackSel"),
    blindsSel: document.getElementById("blindsSel"),

    startGameBtn: document.getElementById("startGameBtn"),
    newHandBtn: document.getElementById("newHandBtn"),
    newGameBtn: document.getElementById("newGameBtn"),

    topupPlayer: document.getElementById("topupPlayer"),
    topupAmt: document.getElementById("topupAmt"),
    topupBtn: document.getElementById("topupBtn"),

    actionFold: document.getElementById("actionFold"),
    actionCall: document.getElementById("actionCall"),
    actionRaise: document.getElementById("actionRaise"),
    raiseAmt: document.getElementById("raiseAmt"),

    chatBox: document.getElementById("chatBox"),
    chatMsg: document.getElementById("chatMsg"),
    chatSend: document.getElementById("chatSend"),

    boardRow: document.getElementById("boardRow"),
    myHandRow: document.getElementById("myHandRow"),
    seatLayer: document.getElementById("seatLayer"),
    tableEl: document.getElementById("table"),
  };

  ui.room.textContent = room;
  ui.me.textContent = name;

  function switchTab(which){
    const gameOn = which === "game";
    ui.tabGame.classList.toggle("active", gameOn);
    ui.tabChat.classList.toggle("active", !gameOn);
    ui.viewGame.classList.toggle("hidden", !gameOn);
    ui.viewChat.classList.toggle("hidden", gameOn);
  }
  ui.tabGame.onclick = ()=>switchTab("game");
  ui.tabChat.onclick = ()=>switchTab("chat");
  switchTab("game");

  // ===== k√°rty√°k =====
  const SUITS=["‚ô†","‚ô•","‚ô¶","‚ô£"];
  const RANKS=["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
  const RANK_VALUE=Object.fromEntries(RANKS.map((r,i)=>[r,i+2]));

  function isRedSuit(s){ return s==="‚ô•" || s==="‚ô¶"; }
  function renderCard(c){
    const d=document.createElement("div");
    d.className="card"+(isRedSuit(c.s)?" red":"");
    d.innerHTML = `<div style="font-weight:900;font-size:16px;line-height:1">${c.r}</div>
                   <div style="align-self:flex-end;font-size:16px;line-height:1">${c.s}</div>`;
    return d;
  }
  function faceDown(){
    const d=document.createElement("div");
    d.className="card";
    d.style.background="rgba(0,0,0,.18)";
    d.style.color="rgba(255,255,255,.65)";
    d.innerHTML="<div style='font-weight:900'>?</div><div style='align-self:flex-end'>üÇ†</div>";
    return d;
  }
  function makeDeck(){
    const d=[];
    for(const s of SUITS) for(const r of RANKS) d.push({r,s});
    return d;
  }
  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  // ===== eval (7->best 5) =====
  function findStraightHigh(uniqueValsDesc){
    const set=new Set(uniqueValsDesc);
    const wheel=[14,5,4,3,2];
    if(wheel.every(v=>set.has(v))) return 5;
    for(const high of uniqueValsDesc){
      let ok=true;
      for(let d=1;d<=4;d++){ if(!set.has(high-d)){ ok=false; break; } }
      if(ok) return high;
    }
    return null;
  }
  function evaluate7(cards){
    const vals=cards.map(c=>RANK_VALUE[c.r]).sort((a,b)=>b-a);
    const byRank=new Map();
    for(const c of cards){ const v=RANK_VALUE[c.r]; byRank.set(v,(byRank.get(v)||0)+1); }
    const groups=[...byRank.entries()].map(([v,c])=>({v,c})).sort((a,b)=>(b.c-a.c)||(b.v-a.v));
    const bySuit=new Map();
    for(const c of cards){ if(!bySuit.has(c.s)) bySuit.set(c.s,[]); bySuit.get(c.s).push(RANK_VALUE[c.r]); }
    for(const [s,arr] of bySuit) arr.sort((a,b)=>b-a);
    const flushSuit=[...bySuit.entries()].find(([s,arr])=>arr.length>=5)?.[0] ?? null;

    const unique=[...new Set(vals)];
    const straight=findStraightHigh(unique);

    let sf=null;
    if(flushSuit){
      const fv=[...new Set(bySuit.get(flushSuit))].sort((a,b)=>b-a);
      sf=findStraightHigh(fv);
    }
    if(sf) return {cat:8,t:[sf],name:"sz√≠nsor"};
    if(groups[0]?.c===4){ const q=groups[0].v; const k=unique.find(v=>v!==q); return {cat:7,t:[q,k],name:"p√≥ker"}; }
    if(groups[0]?.c===3 && groups[1]?.c>=2) return {cat:6,t:[groups[0].v,groups[1].v],name:"full house"};
    if(flushSuit) return {cat:5,t:bySuit.get(flushSuit).slice(0,5),name:"sz√≠n"};
    if(straight) return {cat:4,t:[straight],name:"sor"};
    if(groups[0]?.c===3){
      const tr=groups[0].v;
      const k=unique.filter(v=>v!==tr).slice(0,2);
      return {cat:3,t:[tr,...k],name:"drill"};
    }
    if(groups[0]?.c===2 && groups[1]?.c===2){
      const hi=Math.max(groups[0].v,groups[1].v), lo=Math.min(groups[0].v,groups[1].v);
      const k=unique.find(v=>v!==hi && v!==lo);
      return {cat:2,t:[hi,lo,k],name:"k√©t p√°r"};
    }
    if(groups[0]?.c===2){
      const pr=groups[0].v;
      const k=unique.filter(v=>v!==pr).slice(0,3);
      return {cat:1,t:[pr,...k],name:"p√°r"};
    }
    return {cat:0,t:unique.slice(0,5),name:"magas lap"};
  }
  function cmpEval(a,b){
    if(a.cat!==b.cat) return a.cat>b.cat?1:-1;
    for(let i=0;i<Math.max(a.t.length,b.t.length);i++){
      const av=a.t[i]??0, bv=b.t[i]??0;
      if(av!==bv) return av>bv?1:-1;
    }
    return 0;
  }

  // ===== WS + state =====
  let ws=null, clientId=null, hostId=null, mySeat=null;
  let lobby = { humans:[], ready:{}, cfg:{bots:3, stack:1000, blinds:"10,20"}, started:false };
  let state = null;
  let hostState = null;

  function isHost(){ return clientId && hostId && clientId===hostId; }
  function send(obj){ if(ws && ws.readyState===1) ws.send(JSON.stringify(obj)); }

  // chat
  function appendChat(n,t){
    const p=document.createElement("p");
    p.className="chatline";
    p.innerHTML = `<b>${n}:</b> ${t}`;
    ui.chatBox.appendChild(p);
    ui.chatBox.scrollTop = ui.chatBox.scrollHeight;
  }
  ui.chatSend.onclick = ()=>{
    const text = ui.chatMsg.value.trim().slice(0,300);
    if(!text) return;
    ui.chatMsg.value="";
    send({ type:"intent", intent:"chat", text });
  };
  ui.chatMsg.addEventListener("keydown",(e)=>{ if(e.key==="Enter") ui.chatSend.click(); });

  // ready
  ui.readyBtn.onclick = ()=>{
    const cur = !!lobby.ready[clientId];
    send({ type:"intent", intent: cur ? "unready" : "ready" });
  };
  function everyoneReady(){
    return lobby.humans.length>0 && lobby.humans.every(h => lobby.ready[h.clientId] === true);
  }

  // host config k√ºld√©s
  function pushHostCfg(){
    if(!isHost()) return;
    const cfg = {
      bots: Number(ui.botCount.value||0),
      stack: Number(ui.stackSel.value||1000),
      blinds: ui.blindsSel.value
    };
    send({ type:"intent", intent:"hostConfig", cfg });
  }
  ui.botCount.onchange = pushHostCfg;
  ui.stackSel.onchange = pushHostCfg;
  ui.blindsSel.onchange = pushHostCfg;

  // ===== motor =====
  function nextEligibleIndex(st, from){
    const n=st.players.length;
    for(let t=1;t<=n;t++){
      const idx=(from+t)%n;
      const p=st.players[idx];
      if(p.inHand && !p.folded) return idx;
    }
    return from;
  }
  function nextActionIndex(st, from){
    const n=st.players.length;
    for(let t=1;t<=n;t++){
      const idx=(from+t)%n;
      const p=st.players[idx];
      if(p.inHand && !p.folded && !p.allIn) return idx;
    }
    return null;
  }
  function countAlive(st){ return st.players.filter(p=>p.inHand && !p.folded).length; }
  function amountToCall(st,p){ return Math.max(0, st.currentBet - p.bet); }
  function bettingClosed(st){
    if(countAlive(st)<=1) return true;
    const elig=st.players.filter(p=>p.inHand && !p.folded && !p.allIn);
    if(elig.length===0) return true;
    const acted=new Set(st.acted||[]);
    for(const p of elig){
      if(p.bet!==st.currentBet) return false;
      if(!acted.has(p.id)) return false;
    }
    return true;
  }
  function hist(st, text){
    st.history = st.history || [];
    st.history.push(text);
    if(st.history.length > 250) st.history.shift();
    st.msg = text;
  }
  function postBlind(st, idx, amt, label){
    const p=st.players[idx];
    const pay=Math.min(amt, p.stack);
    p.stack-=pay; p.bet+=pay; p.totalInvested+=pay; st.pot+=pay;
    if(p.stack===0) p.allIn=true;
    hist(st, `${p.name} posztolja: ${label} ${pay}`);
  }
  function startHand(st){
    st.handNo++;
    st.history = [];
    hist(st, `=== ${st.handNo}. k√∂r indul ===`);

    st.deck = shuffle(makeDeck());
    st.community=[];
    st.pot=0;
    st.street="PREFLOP";
    st.currentBet=0;
    st.acted=[];
    st.handActive=true;

    for(const p of st.players){
      p.hand=[];
      p.inHand = p.stack>0;
      p.folded = !p.inHand;
      p.allIn=false;
      p.bet=0;
      p.totalInvested=0;
      p._eval=null;
    }

    st.dealer = nextEligibleIndex(st, st.dealer);

    for(let k=0;k<2;k++){
      for(let i=0;i<st.players.length;i++){
        const idx=(st.dealer+1+i)%st.players.length;
        if(st.players[idx].inHand) st.players[idx].hand.push(st.deck.pop());
      }
    }

    st.sbIndex = nextEligibleIndex(st, st.dealer);
    st.bbIndex = nextEligibleIndex(st, st.sbIndex);

    postBlind(st, st.sbIndex, st.cfg.sb, "SB");
    postBlind(st, st.bbIndex, st.cfg.bb, "BB");

    st.currentBet = Math.max(...st.players.map(p=>p.bet));
    st.toAct = nextEligibleIndex(st, st.bbIndex);
    st.acted = [];
    hist(st, `Preflop indul. Aktu√°lis t√©t: ${st.currentBet}.`);
  }
  function actFold(st, idx){
    st.players[idx].folded=true;
    st.acted.push(idx);
    hist(st, `${st.players[idx].name}: dob√°s`);

    if(countAlive(st)<=1){
      const w=st.players.find(p=>p.inHand && !p.folded);
      if(w) w.stack += st.pot;
      st.handActive=false;
      st.street="SHOWDOWN";
      hist(st, `Mindenki dobott. Nyertes: ${w?.name ?? "‚Äî"} (+${st.pot})`);
      return;
    }
    st.toAct = bettingClosed(st) ? null : nextActionIndex(st, idx);
  }
  function actCallCheck(st, idx){
    const p=st.players[idx];
    const call=amountToCall(st,p);
    const pay=Math.min(call, p.stack);
    p.stack-=pay; p.bet+=pay; p.totalInvested+=pay; st.pot+=pay;
    if(p.stack===0 && call>0) p.allIn=true;

    if(call===0) hist(st, `${p.name}: passz`);
    else hist(st, `${p.name}: megad ${pay}${pay<call ? " (all-in)" : ""}`);

    st.acted.push(idx);
    st.toAct = bettingClosed(st) ? null : nextActionIndex(st, idx);
  }
  function actRaiseTo(st, idx, raiseToRaw){
    const p=st.players[idx];
    let raiseTo = Number(raiseToRaw||0);

    if(raiseTo <= st.currentBet){
      actCallCheck(st, idx);
      return;
    }

    const need=Math.max(0, raiseTo - p.bet);
    const pay=Math.min(need, p.stack);
    p.stack-=pay; p.bet+=pay; p.totalInvested+=pay; st.pot+=pay;
    if(p.stack===0) p.allIn=true;

    st.currentBet = p.bet;
    st.acted = [idx];
    hist(st, `${p.name}: emel ${st.currentBet}-ig${p.allIn ? " (all-in)" : ""}`);

    st.toAct = bettingClosed(st) ? null : nextActionIndex(st, idx);
  }
  function advanceStreet(st){
    if(!st.handActive) return;
    if(!bettingClosed(st)) return;

    if(countAlive(st)<=1){
      const w=st.players.find(p=>p.inHand && !p.folded);
      if(w) w.stack += st.pot;
      st.handActive=false;
      st.street="SHOWDOWN";
      hist(st, `Nyertes: ${w?.name ?? "‚Äî"} (+${st.pot})`);
      return;
    }

    for(const p of st.players) p.bet = 0;
    st.currentBet = 0;
    st.acted = [];
    st.toAct = nextEligibleIndex(st, st.dealer);

    if(st.street==="PREFLOP"){
      st.deck.pop();
      st.community.push(st.deck.pop(), st.deck.pop(), st.deck.pop());
      st.street="FLOP";
      hist(st, "Flop.");
    } else if(st.street==="FLOP"){
      st.deck.pop();
      st.community.push(st.deck.pop());
      st.street="TURN";
      hist(st, "Turn.");
    } else if(st.street==="TURN"){
      st.deck.pop();
      st.community.push(st.deck.pop());
      st.street="RIVER";
      hist(st, "River.");
    } else if(st.street==="RIVER"){
      st.street="SHOWDOWN";
      doShowdown(st);
    }
  }
  function doShowdown(st){
    const alive=st.players.filter(p=>p.inHand && !p.folded);
    if(alive.length===0){ st.handActive=false; hist(st,"Showdown: nincs akt√≠v j√°t√©kos."); return; }

    let bestEval=null;
    for(const p of alive){
      const e = evaluate7(p.hand.concat(st.community));
      p._eval = e;
      if(!bestEval || cmpEval(e, bestEval) > 0) bestEval = e;
    }
    const winners = alive.filter(p => cmpEval(p._eval, bestEval) === 0);

    const pot = st.pot;
    const share = Math.floor(pot / winners.length);
    let rem = pot - share * winners.length;

    for(const w of winners) w.stack += share;
    for(let i=0; i<winners.length && rem>0; i++){ winners[i].stack += 1; rem--; }

    const names = winners.map(w=>w.name).join(", ");
    st.handActive=false;

    if(winners.length === 1) hist(st, `Showdown: ${names} nyert (+${pot}) ‚Äì ${bestEval.name}`);
    else hist(st, `D√∂ntetlen! Nyertek: ${names}. Pot osztva (${share} / f≈ë) ‚Äì ${bestEval.name}`);
  }

  // ===== bot 3mp delay =====
  let botTimer = null;
  function scheduleBotIfNeeded(){
    if(!isHost() || !hostState) return;
    if(!hostState.handActive) return;
    if(hostState.toAct == null) return;
    const p = hostState.players?.[hostState.toAct];
    if(!p || !p.isBot) return;
    if(botTimer) return;

    botTimer = setTimeout(() => {
      botTimer = null;
      if(!hostState || !hostState.handActive) return;
      const idx = hostState.toAct;
      const bp = hostState.players?.[idx];
      if(!bp || !bp.isBot) return;

      const call = amountToCall(hostState, bp);
      const pressure = call / Math.max(1, bp.stack + call);
      const r=Math.random();

      if(call>0 && pressure>0.45 && r<0.55) actFold(hostState, idx);
      else if(r<0.12 && bp.stack > call + hostState.cfg.bb) actRaiseTo(hostState, idx, hostState.currentBet + hostState.cfg.bb);
      else actCallCheck(hostState, idx);

      while(hostState.handActive && hostState.street!=="SHOWDOWN" && bettingClosed(hostState)){
        advanceStreet(hostState);
      }

      send({ type:"state", state: hostState });
      scheduleBotIfNeeded();
    }, 3000);
  }

  function buildInitialState(){
    const humans = lobby.humans.slice();
    const bots = Number(lobby.cfg.bots||0);
    const stack = Number(lobby.cfg.stack||1000);
    const [sb,bb] = String(lobby.cfg.blinds||"10,20").split(",").map(n=>Number(n));

    const players = [
      ...humans.map((h,idx)=>({
        id: idx, name: h.name, isBot:false,
        stack, hand:[], inHand:true, folded:false, allIn:false, bet:0, totalInvested:0
      })),
      ...Array.from({length:bots}).map((_,i)=>({
        id: humans.length+i, name:`Robot #${i+1}`, isBot:true,
        stack, hand:[], inHand:true, folded:false, allIn:false, bet:0, totalInvested:0
      }))
    ];

    return {
      cfg:{ sb, bb, stack, bots },
      history: [],
      handNo:0,
      dealer:0,
      sbIndex:null,
      bbIndex:null,
      deck:[],
      community:[],
      pot:0,
      street:"PREFLOP",
      toAct:null,
      currentBet:0,
      acted:[],
      handActive:false,
      msg:"J√°t√©k indul!",
      players
    };
  }

  function startGameAsHost(){
    if(!everyoneReady()) return alert("Nem minden ember K√âSZ m√©g.");
    lobby.started = true;
    hostState = buildInitialState();
    startHand(hostState);
    send({ type:"start", state: hostState });
    send({ type:"state", state: hostState });
    scheduleBotIfNeeded();
  }
  function newHandAsHost(){
    if(!hostState || !lobby.started) return alert("M√©g nincs elind√≠tva a j√°t√©k.");
    if(hostState.handActive) return alert("A leoszt√°s m√©g tart.");
    startHand(hostState);
    send({ type:"state", state: hostState });
    scheduleBotIfNeeded();
  }
  function newGameAsHost(){
    if(!everyoneReady()) return alert("√öj j√°t√©khoz minden ember legyen K√âSZ.");
    lobby.started = true;
    hostState = buildInitialState();
    startHand(hostState);
    send({ type:"start", state: hostState });
    send({ type:"state", state: hostState });
    scheduleBotIfNeeded();
  }

  function handleIntentAsHost(msg){
    if(!hostState || !hostState.handActive) return;
    if(msg.intent !== "action") return;
    const seat = msg.seat;
    if(seat==null) return;
    if(hostState.toAct !== seat) return;

    const p = hostState.players[seat];
    if(!p || p.isBot) return;

    if(msg.action==="fold") actFold(hostState, seat);
    if(msg.action==="call") actCallCheck(hostState, seat);
    if(msg.action==="raise") actRaiseTo(hostState, seat, Number(msg.amount||0));

    while(hostState.handActive && hostState.street!=="SHOWDOWN" && bettingClosed(hostState)){
      advanceStreet(hostState);
    }

    send({ type:"state", state: hostState });
    scheduleBotIfNeeded();
  }

  // action intents
  ui.actionFold.onclick = ()=> send({ type:"intent", intent:"action", action:"fold", amount:0 });
  ui.actionCall.onclick = ()=> send({ type:"intent", intent:"action", action:"call", amount:0 });
  ui.actionRaise.onclick = ()=> send({ type:"intent", intent:"action", action:"raise", amount:Number(ui.raiseAmt.value||0) });

  // host gombok
  ui.startGameBtn.onclick = ()=> { if(!isHost()) return; if(lobby.started) return alert("A j√°t√©k m√°r elindult."); startGameAsHost(); };
  ui.newHandBtn.onclick  = ()=> { if(!isHost()) return; newHandAsHost(); };
  ui.newGameBtn.onclick  = ()=> { if(!isHost()) return; newGameAsHost(); };

  // ===== √úLTET√âS: k√∂rben dinamikusan =====
  function getSeatPos(i, n){
    const angleStart = -Math.PI/2;
    const step = (2*Math.PI) / Math.max(2,n);
    const a = angleStart + i*step;

    const rect = ui.tableEl.getBoundingClientRect();
    const rx = rect.width * 0.40;
    const ry = rect.height * 0.36;

    const cx = 50, cy = 50;
    const x = cx + (Math.cos(a) * (rx / rect.width) * 100);
    const y = cy + (Math.sin(a) * (ry / rect.height) * 100);
    return {x, y};
  }

  function renderTable(st){
    ui.boardRow.innerHTML="";
    for(const c of (st.community||[])) ui.boardRow.appendChild(renderCard(c));

    ui.myHandRow.innerHTML = "";
    if(mySeat!=null && st.players?.[mySeat]?.hand?.length===2){
      ui.myHandRow.appendChild(renderCard(st.players[mySeat].hand[0]));
      ui.myHandRow.appendChild(renderCard(st.players[mySeat].hand[1]));
    } else {
      ui.myHandRow.appendChild(faceDown());
      ui.myHandRow.appendChild(faceDown());
    }

    const showAllHands = (st.street === "SHOWDOWN") || (!st.handActive);

    ui.seatLayer.innerHTML="";
    const players = st.players || [];
    const n = players.length;

    for(let i=0;i<n;i++){
      const p = players[i];
      const pos = getSeatPos(i, n);

      const el = document.createElement("div");
      el.className = "seat";
      el.style.left = pos.x + "%";
      el.style.top  = pos.y + "%";

      if(st.toAct===i && st.handActive) el.classList.add("toAct");
      if(p.folded) el.classList.add("folded");
      if(mySeat===i) el.classList.add("me");

      const badges = [];
      if(i===st.dealer) badges.push(`<span class="pill d">D</span>`);
      if(i===st.sbIndex) badges.push(`<span class="pill sb">SB</span>`);
      if(i===st.bbIndex) badges.push(`<span class="pill bb">BB</span>`);

      el.innerHTML = `
        <div class="topline">
          <div class="name" title="${p.name}">${p.name}${p.isBot?" ü§ñ":""}</div>
          <div class="meta">üí∞ ${p.stack}</div>
        </div>
        <div class="badges">${badges.join(" ")}</div>
        <div class="small">T√©t: ${p.bet} ${p.folded ? "‚Ä¢ DOBOTT" : (p.allIn ? "‚Ä¢ ALL-IN" : "")}</div>
      `;

      if(showAllHands && !p.folded && p.hand?.length===2){
        const handRow = document.createElement("div");
        handRow.className = "handMini";
        handRow.appendChild(renderCard(p.hand[0]));
        handRow.appendChild(renderCard(p.hand[1]));
        el.appendChild(handRow);

        if(p._eval){
          const ev = document.createElement("div");
          ev.className = "small";
          ev.textContent = `Komb√≥: ${p._eval.name}`;
          el.appendChild(ev);
        }
      }

      ui.seatLayer.appendChild(el);
    }
  }

  function render(){
    ui.host.textContent = hostId || "‚Äî";
    ui.seat.textContent = (mySeat==null ? "‚Äî" : String(mySeat));
    ui.startInfo.textContent = lobby.started ? "J√°t√©k fut" : "V√°rakoz√°s (K√©sz / Ready)‚Ä¶";

    ui.hostOnly.style.display = isHost() ? "" : "none";

    // ===== LOBBY LIST =====
    ui.players.innerHTML = "";
    for(const h of (lobby.humans||[])){
      const row=document.createElement("div");
      row.className="pitem";
      row.innerHTML = `<div>${h.name}</div>`;
      const right=document.createElement("span");
      const ok = lobby.ready[h.clientId] === true;
      right.className = "pill " + (ok ? "ready" : "notready");
      right.textContent = ok ? "K√âSZ" : "NEM K√âSZ";
      row.appendChild(right);
      ui.players.appendChild(row);
    }

    // ===== TOPUP LISTA: CSAK EMBEREK =====
    if (isHost() && ui.topupPlayer) {
      ui.topupPlayer.innerHTML = "";

      // ember seat indexek (0..humans-1), botok kimaradnak
      const humanSeats = (lobby.humans || []).map(h => h.seat);

      // ha van state, onnan olvassuk a stack-et
      const src = hostState || state;

      humanSeats.forEach(seatIdx => {
        const p = src?.players?.[seatIdx];
        if(!p || p.isBot) return;
        const opt = document.createElement("option");
        opt.value = String(seatIdx);
        opt.textContent = `${p.name} (zseton: ${p.stack})`;
        ui.topupPlayer.appendChild(opt);
      });

      ui.topupBtn.disabled = !(hostState || state) || ui.topupPlayer.options.length === 0;
    }

    // ===== ha nincs j√°t√©k =====
    if(!lobby.started || !state){
      ui.streetLbl.textContent = "‚Äî";
      ui.currentBetLbl.textContent = "0";
      ui.potLbl.textContent = "0";
      ui.handNoLbl.textContent = "0";
      ui.actionFold.disabled = true;
      ui.actionCall.disabled = true;
      ui.actionRaise.disabled = true;
      ui.turnHint.textContent = "V√°rakoz√°s a host ind√≠t√°s√°ra‚Ä¶";
      ui.log.textContent = "";
      ui.boardRow.innerHTML="";
      ui.myHandRow.innerHTML="";
      ui.seatLayer.innerHTML="";
      return;
    }

    ui.streetLbl.textContent = ({PREFLOP:"Preflop",FLOP:"Flop",TURN:"Turn",RIVER:"River",SHOWDOWN:"Showdown"}[state.street]||state.street);
    ui.currentBetLbl.textContent = String(state.currentBet || 0);
    ui.potLbl.textContent = String(state.pot || 0);
    ui.handNoLbl.textContent = String(state.handNo || 0);

    renderTable(state);

    if(state.history && Array.isArray(state.history)){
      ui.log.textContent = state.history.join("\n");
      ui.log.scrollTop = ui.log.scrollHeight;
    } else ui.log.textContent = "";

    const canAct = state.handActive && state.toAct===mySeat;
    ui.actionFold.disabled = !canAct;
    ui.actionCall.disabled = !canAct;
    ui.actionRaise.disabled = !canAct;

    if(!state.handActive){
      ui.turnHint.textContent = "A leoszt√°s v√©get √©rt. Host: üîÑ √öJ K√ñR vagy üîÅ √öJ J√ÅT√âK.";
    } else if(state.toAct == null || !state.players[state.toAct]){
      ui.turnHint.textContent = "V√°rakoz√°s‚Ä¶";
    } else {
      const actor = state.players[state.toAct];
      const callAmt = amountToCall(state, actor);
      const raiseTo = Number(ui.raiseAmt.value || 0);
      const base = `${actor.name} k√∂vetkezik. Megadand√≥: ${callAmt}. Aktu√°lis t√©t: ${state.currentBet}.`;

      if(state.toAct === mySeat){
        ui.turnHint.textContent = callAmt===0
          ? `${base} Te vagy soron: PASSZ / EMEL√âS ${raiseTo}-ig / DOB√ÅS.`
          : `${base} Te vagy soron: MEGAD√ÅS ${callAmt} / EMEL√âS ${raiseTo}-ig / DOB√ÅS.`;
      } else {
        ui.turnHint.textContent = `${base} V√°rakoz√°s‚Ä¶ ${actor.isBot ? "(robot gondolkodik‚Ä¶)" : "(j√°t√©kos d√∂nt)"}`;
      }
    }
  }

  // ===== Host: zseton ad√°sa (csak ember seat) =====
  ui.topupBtn.onclick = () => {
    if(!isHost() || !hostState) return;

    const seatIdx = Number(ui.topupPlayer.value);
    const amt = Math.max(1, Number(ui.topupAmt.value || 0));
    const p = hostState.players?.[seatIdx];
    if(!p || p.isBot) return;

    p.stack += amt;
    if(p.stack > 0) p.allIn = false;

    hostState.history = hostState.history || [];
    hostState.history.push(`HOST: ${p.name} kapott +${amt} zsetont.`);
    hostState.msg = `HOST zsetont adott: ${p.name} +${amt}`;

    send({ type:"state", state: hostState });
  };

  // ===== WS connect =====
  function connect(){
    ui.status.textContent = "csatlakoz√°s‚Ä¶";
    ws = new WebSocket(wsUrl);

    ws.addEventListener("open", ()=>{
      ui.status.textContent = "online";
      send({ type:"join", room, name, pw });
    });

    ws.addEventListener("close", ()=> ui.status.textContent = "offline");
    ws.addEventListener("error", ()=> ui.status.textContent = "hiba");

    ws.addEventListener("message", (ev)=>{
      let msg;
      try{ msg = JSON.parse(ev.data); } catch { return; }

      if(msg.type==="welcome"){
        clientId = msg.clientId;
        hostId = msg.hostId;
        mySeat = msg.seat;
        send({ type:"getLobby" });
        render();
        return;
      }

      if(msg.type==="hostChanged"){ hostId = msg.hostId; render(); return; }
      if(msg.type==="lobby"){ lobby = msg.lobby; hostId = msg.hostId; render(); return; }

      if(msg.type==="start"){
        lobby.started = true;
        state = msg.state;
        if(isHost()) hostState = JSON.parse(JSON.stringify(state));
        render();
        scheduleBotIfNeeded();
        return;
      }

      if(msg.type==="state"){
        state = msg.state;
        if(isHost()) hostState = JSON.parse(JSON.stringify(state));
        render();
        scheduleBotIfNeeded();
        return;
      }

      if(msg.type==="chat"){ appendChat(msg.name, msg.text); return; }
      if(msg.type==="intent" && isHost()){ handleIntentAsHost(msg); return; }
      if(msg.type==="error"){ alert(msg.message || "Hiba"); }
    });

    window.addEventListener("resize", ()=> { if(state) render(); });
  }

  connect();
</script>
</body>
</html>
